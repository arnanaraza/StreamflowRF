mrb.VT.yes <- groupVT('mrb', 0.6, 'yes')
str(mrb.VT.yes)
# 1. VALUETABLE ASSEMBLY
source('R/groupVT.R')
mrb.VT.yes <- groupVT('mrb', 0.6, 'yes')
# 1. VALUETABLE ASSEMBLY
source('R/groupVT.R')
r
mrb.VT.yes <- groupVT('mrb', 0.6, 'yes')
str9mrb.VT.yes
str(mrb.VT.yes)
# 1. VALUETABLE ASSEMBLY
source('R/groupVT.R')
mrb.VT.yes <- groupVT('mrb', 0.6, 'yes')
str(mrb.VT.yes)
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17,58)])))
#watersheds
each.VT <- lapply(1:length(SW.list), function(x) groupVT(SW.list[[x]], 0.6, 'yes'))
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17,58)])))
km.a <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
each.mean
head(each.mean)
head(each.mean[1])
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-17)])))
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-17)]))
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-17)]))
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
a=each.mean[[1]]
a
each.mean <- ldply(each.mean,data.frame)
each.mean <- as.data.frame(scale(each.mean))
each.mean
each.mean <-each.mean[,-4]
rownames(each.mean) <- SW.list
names (each.mean) <- nims
each.mean <- each.mean[ , order(names(each.mean),decreasing = T)]
names (each.mean)
each.mean <- each.mean[ , order(names(each.mean),decreasing = T)]
names(each.mean)
each.covs <- t(each.mean) #other way around
each.covs
dist <- get_dist(each.mean)
# k means solid
km.a <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
km.a
#######solid pca
prin_comp <- prcomp(each.covs, scale = T)
var <- get_pca_var(prin_comp)
pacman::p_load(caTools, lubridate, rfUtilities, ranger, hydroGOF,factoextra,
rgdal,raster, plyr, dplyr , data.table, reshape2, varhandle, xts,
Hmisc, splitstackshape,ggplot2, ggpmisc, caret, gridExtra,ggpubr,Rmisc)
#######solid pca
prin_comp <- prcomp(each.covs, scale = T)
var <- get_pca_var(prin_comp)
corrplot(var$cor[,1:10], is.corr	=F,tl.cex = 1)
pacman::p_load(caTools, lubridate, rfUtilities, ranger, hydroGOF,factoextra,corrplot,
rgdal,raster, plyr, dplyr , data.table, reshape2, varhandle, xts,
Hmisc, splitstackshape,ggplot2, ggpmisc, caret, gridExtra,ggpubr,Rmisc)
corrplot(var$cor[,1:10], is.corr	=F,tl.cex = 1)
fviz_pca_ind(prin_comp, axes = c(4, 5),
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),labelsize = 5, pointsize = 1,
repel = TRUE, ggtheme=theme(axis.text=element_text(size=10), axis.title=element_text(size=16, face="bold")))
fviz_nbclust(each.mean, kmeans, nstart = 25,  method = "gap_stat", nboot = 100)
corrplot(cor(each.mean), type = 'upper', tl.cex = 0.6)
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
clstr
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
clstr
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
clstr
#watersheds
set.seed(1234)
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
clstr
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
clstr
clstr$cluster
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)[[1]]
clstr
#assign clusters from k-means/pca clustering
pca1.VT <-  groupVT('pca1', 0.6, 'yes')
clstr
groupVT <- function(basin,td=0.8, floss='no'){
# PCA-based on 'clstr' variable
if(basin=='pca'){basin=clstr}
if (basin == 1){
SW.list <- SW.list[clstr==1]
print(paste(SW.list, 'is PCA1'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 2){
SW.list <- SW.list[clstr==2]
print(paste(SW.list, 'is PCA2'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 3){
SW.list <- SW.list[clstr==3]
print(paste(SW.list, 'is PCA3'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 4){
SW.list <-SW.list[clstr==4]
print(paste(SW.list, 'is PCA4'))
SW.conv <-rep('no', length(SW.list))
} else{print('clusters limited to 4')}
# group all watersheds
if (basin == 'all'){
SW.list <- c('aarb_a', 'aarb_n', 'abrb_s','arb_b', 'arb_c', 'crb_a', 'crb_be',
'crb_bu', 'crb_d', 'crb_j','crb_m', 'crb_p', 'crb_s',
'crb_t', 'crb_u', 'mrb_s', 'prb_b', 'prb_c', 'prb_a',
'prb_p', 'prb_r')
SW.conv <- c ('yes', 'no', 'no', 'no', 'no','yes', 'no', 'no', 'no','no',
'no','no','no','no','no','no','no','no','yes', 'no', 'no')}
#group per mother basin
if (basin == 'aarb'){
SW.list <-  c('aarb_a', 'aarb_n')
SW.conv <- c ('yes', 'no')}
if (basin == 'abrb'){
SW.list <-  'abrb_s'
SW.conv <-'no'}
if (basin == 'arb'){
SW.list <-  c('arb_b', 'arb_c')
SW.conv <- c ('no', 'no')}
if (basin == 'crb'){
SW.list <- c('crb_a', 'crb_be', 'crb_bu', 'crb_d', 'crb_j','crb_m', 'crb_p', 'crb_s', 'crb_t', 'crb_u')
SW.conv <- c('yes', 'no', 'no', 'no','no','no','no','no','no','no')}
if (basin == 'mrb'){
SW.list <-  'mrb_s'
SW.conv <-'no'}
if (basin == 'prb'){
SW.list <- c('prb_b', 'prb_c', 'prb_a', 'prb_p', 'prb_r')
SW.conv <- c('no','no','yes', 'no', 'no')}
# no grouping, stand-alone watershed tables
if (basin == 'aarb_a'){
SW.list <-  c('aarb_a')
SW.conv <- c ('no')}
if (basin == 'aarb_n'){
SW.list <-  c('aarb_n')
SW.conv <- c ('no')}
if (basin == 'abrb_s'){
SW.list <-  c('abrb_s')
SW.conv <- c ('no')}
if (basin == 'arb_b'){
SW.list <-  c('arb_b')
SW.conv <- c ('no')}
if (basin == 'arb_c'){
SW.list <-  c('arb_c')
SW.conv <- c ('no')}
if (basin == 'crb_a'){
SW.list <-  c('crb_a')
SW.conv <- c ('no')}
if (basin == 'crb_be'){
SW.list <-  c('crb_be')
SW.conv <- c ('no')}
if (basin == 'crb_bu'){
SW.list <-  c('crb_bu')
SW.conv <- c ('no')}
if (basin == 'crb_d'){
SW.list <-  c('crb_d')
SW.conv <- c ('no')}
if (basin == 'crb_j'){
SW.list <-  c('crb_j')
SW.conv <- c ('no')}
if (basin == 'crb_m'){
SW.list <-  c('crb_m')
SW.conv <- c ('no')}
if (basin == 'crb_p'){
SW.list <-  c('crb_p')
SW.conv <- c ('no')}
if (basin == 'crb_s'){
SW.list <-  c('crb_s')
SW.conv <- c ('no')}
if (basin == 'crb_t'){
SW.list <-  c('crb_t')
SW.conv <- c ('no')}
if (basin == 'crb_u'){
SW.list <-  c('crb_u')
SW.conv <- c ('no')}
if (basin == 'mrb_s'){
SW.list <-  c('mrb_s')
SW.conv <- c ('no')}
if (basin == 'prb_a'){
SW.list <-  c('prb_a')
SW.conv <- c ('no')}
if (basin == 'prb_b'){
SW.list <-  c('prb_b')
SW.conv <- c ('no')}
if (basin == 'prb_c'){
SW.list <-  c('prb_c')
SW.conv <- c ('no')}
if (basin == 'prb_p'){
SW.list <-  c('prb_p')
SW.conv <- c ('no')}
if (basin == 'prb_r'){
SW.list <-  c('prb_r')
SW.conv <- c ('no')}
# Wrapper for the data frame assembly of value tables
source('R/shedVT.R')
all.VT <- lapply(SW.list, function(x) shedVT(x, SW.conv)) # yes are aarb_a, crb_a, prb_a
all.VT1 <- lapply(all.VT, function(x) x[-c(1:730),]) #remove <year 2000
# value table formatting
vt.names <- c('LC1.agr', 'LC2.for', 'LC3.gr', 'LC4.wgr', 'LC5.wetl',
'LC6.riv', 'LC7.bu', 'LC8.barr', 'LC9.CN', 'LC10.man',
'LC11.fl', 'W1.ws', 'W2.tmin', 'W3.tmax', 'W4.pcp', 'W5.rh', 'O.obs',
'P.bd1', 'P.br1', 'P.cl1', 'P.sa1', 'P.si1', 'P.dem1', 'P.sl1',
'P.bd2', 'P.br2', 'P.cl2', 'P.sa2', 'P.si2', 'P.dem2', 'P.sl2',
'P.bd3', 'P.br3', 'P.cl3', 'P.sa3', 'P.si3', 'P.dem3', 'P.sl3',
'P.bd4', 'P.br4', 'P.cl4', 'P.sa4', 'P.si4', 'P.dem4', 'P.sl4',
'P.bd5', 'P.br5', 'P.cl5', 'P.sa5', 'P.si5', 'P.dem5', 'P.sl5',
'date', 'W6.pcpw', 'W7.pcpm', 'W8.pcpmx', 'C.area', 'C.basin', 'C.size', 'C.clim')
all.VT2 <- lapply(all.VT1, setNames, nm = vt.names)
all.VT3 <- lapply(all.VT2, function(x) unfactor(x))
all.VT.fin <- do.call("rbind", all.VT3)
all.VT.fin <- na.omit(all.VT.fin)
all.VT.fin$mo <- month(all.VT.fin$date)
vt.names <- c(vt.names, 'C.mo')
colnames(all.VT.fin) <- vt.names
all.VT.fin$date <- as.Date(all.VT.fin$date)
all.VT.fin$O.obs <- all.VT.fin$O.obs/1000 #into m3/sec
setwd(vtDir)
write.csv(all.VT.fin, paste0(basin,'_',round(td*100,1),'.csv'), row.names = F)
setwd(mainDir)
all.VT.fin <- all.VT.fin[,-53] #remove date
# create training-testing data
if (td < 1){
set.seed(123)
train <- sample(seq_len(nrow(all.VT.fin)), size = floor((1-td)*nrow(all.VT.fin)))
train <- all.VT.fin[-train,]}
if (td == 1){
train <- all.VT.fin}
# for forest loss assessment?
if (floss == 'yes'){}
if (floss == 'no'){
train <- train [,-c(1:11)]}
train[] <- sapply(train, as.numeric)
return (train)
}
#assign clusters from k-means/pca clustering
pca1.VT <-  groupVT('pca', 0.6, 'yes')
pca2.VT <-  groupVT('pca', 0.6, 'yes')
unique(clstr)
### FUNCTION TO CREATE PRE-DEFINED WATERSHED GROUPING METHODS FOR VALUE TABLE ASSEMBLY
groupVT <- function(basin,td=0.8, floss='no'){
# PCA-based on 'clstr' variable
if (basin == 'pca1'){
SW.list <- SW.list[clstr==1]
print(paste(SW.list, 'is PCA1'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 'pca2'){
SW.list <- SW.list[clstr==2]
print(paste(SW.list, 'is PCA2'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 'pca3'){
SW.list <- SW.list[clstr==3]
print(paste(SW.list, 'is PCA3'))
SW.conv <-rep('no', length(SW.list))
}
if (basin == 'pca4'){
SW.list <-SW.list[clstr==4]
print(paste(SW.list, 'is PCA4'))
SW.conv <-rep('no', length(SW.list))
} else{print('clusters limited to 4')}
# group all watersheds
if (basin == 'all'){
SW.list <- c('aarb_a', 'aarb_n', 'abrb_s','arb_b', 'arb_c', 'crb_a', 'crb_be',
'crb_bu', 'crb_d', 'crb_j','crb_m', 'crb_p', 'crb_s',
'crb_t', 'crb_u', 'mrb_s', 'prb_b', 'prb_c', 'prb_a',
'prb_p', 'prb_r')
SW.conv <- c ('yes', 'no', 'no', 'no', 'no','yes', 'no', 'no', 'no','no',
'no','no','no','no','no','no','no','no','yes', 'no', 'no')}
#group per mother basin
if (basin == 'aarb'){
SW.list <-  c('aarb_a', 'aarb_n')
SW.conv <- c ('yes', 'no')}
if (basin == 'abrb'){
SW.list <-  'abrb_s'
SW.conv <-'no'}
if (basin == 'arb'){
SW.list <-  c('arb_b', 'arb_c')
SW.conv <- c ('no', 'no')}
if (basin == 'crb'){
SW.list <- c('crb_a', 'crb_be', 'crb_bu', 'crb_d', 'crb_j','crb_m', 'crb_p', 'crb_s', 'crb_t', 'crb_u')
SW.conv <- c('yes', 'no', 'no', 'no','no','no','no','no','no','no')}
if (basin == 'mrb'){
SW.list <-  'mrb_s'
SW.conv <-'no'}
if (basin == 'prb'){
SW.list <- c('prb_b', 'prb_c', 'prb_a', 'prb_p', 'prb_r')
SW.conv <- c('no','no','yes', 'no', 'no')}
# no grouping, stand-alone watershed tables
if (basin == 'aarb_a'){
SW.list <-  c('aarb_a')
SW.conv <- c ('no')}
if (basin == 'aarb_n'){
SW.list <-  c('aarb_n')
SW.conv <- c ('no')}
if (basin == 'abrb_s'){
SW.list <-  c('abrb_s')
SW.conv <- c ('no')}
if (basin == 'arb_b'){
SW.list <-  c('arb_b')
SW.conv <- c ('no')}
if (basin == 'arb_c'){
SW.list <-  c('arb_c')
SW.conv <- c ('no')}
if (basin == 'crb_a'){
SW.list <-  c('crb_a')
SW.conv <- c ('no')}
if (basin == 'crb_be'){
SW.list <-  c('crb_be')
SW.conv <- c ('no')}
if (basin == 'crb_bu'){
SW.list <-  c('crb_bu')
SW.conv <- c ('no')}
if (basin == 'crb_d'){
SW.list <-  c('crb_d')
SW.conv <- c ('no')}
if (basin == 'crb_j'){
SW.list <-  c('crb_j')
SW.conv <- c ('no')}
if (basin == 'crb_m'){
SW.list <-  c('crb_m')
SW.conv <- c ('no')}
if (basin == 'crb_p'){
SW.list <-  c('crb_p')
SW.conv <- c ('no')}
if (basin == 'crb_s'){
SW.list <-  c('crb_s')
SW.conv <- c ('no')}
if (basin == 'crb_t'){
SW.list <-  c('crb_t')
SW.conv <- c ('no')}
if (basin == 'crb_u'){
SW.list <-  c('crb_u')
SW.conv <- c ('no')}
if (basin == 'mrb_s'){
SW.list <-  c('mrb_s')
SW.conv <- c ('no')}
if (basin == 'prb_a'){
SW.list <-  c('prb_a')
SW.conv <- c ('no')}
if (basin == 'prb_b'){
SW.list <-  c('prb_b')
SW.conv <- c ('no')}
if (basin == 'prb_c'){
SW.list <-  c('prb_c')
SW.conv <- c ('no')}
if (basin == 'prb_p'){
SW.list <-  c('prb_p')
SW.conv <- c ('no')}
if (basin == 'prb_r'){
SW.list <-  c('prb_r')
SW.conv <- c ('no')}
# Wrapper for the data frame assembly of value tables
source('R/shedVT.R')
all.VT <- lapply(SW.list, function(x) shedVT(x, SW.conv)) # yes are aarb_a, crb_a, prb_a
all.VT1 <- lapply(all.VT, function(x) x[-c(1:730),]) #remove <year 2000
# value table formatting
vt.names <- c('LC1.agr', 'LC2.for', 'LC3.gr', 'LC4.wgr', 'LC5.wetl',
'LC6.riv', 'LC7.bu', 'LC8.barr', 'LC9.CN', 'LC10.man',
'LC11.fl', 'W1.ws', 'W2.tmin', 'W3.tmax', 'W4.pcp', 'W5.rh', 'O.obs',
'P.bd1', 'P.br1', 'P.cl1', 'P.sa1', 'P.si1', 'P.dem1', 'P.sl1',
'P.bd2', 'P.br2', 'P.cl2', 'P.sa2', 'P.si2', 'P.dem2', 'P.sl2',
'P.bd3', 'P.br3', 'P.cl3', 'P.sa3', 'P.si3', 'P.dem3', 'P.sl3',
'P.bd4', 'P.br4', 'P.cl4', 'P.sa4', 'P.si4', 'P.dem4', 'P.sl4',
'P.bd5', 'P.br5', 'P.cl5', 'P.sa5', 'P.si5', 'P.dem5', 'P.sl5',
'date', 'W6.pcpw', 'W7.pcpm', 'W8.pcpmx', 'C.area', 'C.basin', 'C.size', 'C.clim')
all.VT2 <- lapply(all.VT1, setNames, nm = vt.names)
all.VT3 <- lapply(all.VT2, function(x) unfactor(x))
all.VT.fin <- do.call("rbind", all.VT3)
all.VT.fin <- na.omit(all.VT.fin)
all.VT.fin$mo <- month(all.VT.fin$date)
vt.names <- c(vt.names, 'C.mo')
colnames(all.VT.fin) <- vt.names
all.VT.fin$date <- as.Date(all.VT.fin$date)
all.VT.fin$O.obs <- all.VT.fin$O.obs/1000 #into m3/sec
setwd(vtDir)
write.csv(all.VT.fin, paste0(basin,'_',round(td*100,1),'.csv'), row.names = F)
setwd(mainDir)
all.VT.fin <- all.VT.fin[,-53] #remove date
# create training-testing data
if (td < 1){
set.seed(123)
train <- sample(seq_len(nrow(all.VT.fin)), size = floor((1-td)*nrow(all.VT.fin)))
train <- all.VT.fin[-train,]}
if (td == 1){
train <- all.VT.fin}
# for forest loss assessment?
if (floss == 'yes'){}
if (floss == 'no'){
train <- train [,-c(1:11)]}
train[] <- sapply(train, as.numeric)
return (train)
}
#assign clusters from k-means/pca clustering
pca1.VT <-  groupVT('pca1', 0.6, 'yes')
each.mean
each.mean$clstr = clstr
head(each.mean$clstr)
each.mean
?ranger
clstr.rf <- ranger(clstr ~ ., data=each.mean)
clstr.rf
str(each.mean)
clstr.rf <- ranger(as.factor(clstr) ~ ., data=each.mean)
clstr.rf
clstr
each.mean <- each.mean[-sample(1:length(each.mean),2)] #validation sheds(2)
each.mean <- each.mean[-sample(1:nrow(each.mean),2)] #val sheds
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
each.mean <- each.mean[-sample(which(each.mean),2)] #val sheds
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
each.mean
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
km.a <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
each.mean
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
each.mean <- ldply(each.mean,data.frame)
each.mean <- as.data.frame(scale(each.mean))
each.mean
each.mean <-each.mean[,-4]
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)[[1]]
clstr
each.mean$clstr = clstr
clstr.rf <- ranger(as.factor(clstr) ~ ., data=each.mean)
clstr.rf
pca1.VT <-  groupVT('pca1', 0.6, 'yes')
pca2.VT <-  groupVT('pca2', 0.6, 'yes')
RollDie(5)
ample(1:6,10,replace=T)
sample(1:6,10,replace=T)
sample(1:2,10,replace=T)
sample(1:2,1,replace=T)
sample(1:nrow(each.mean),1,replace=T)
sample(1:nrow(each.mean),2,replace=T)
each.mean <- each.mean[sample(1:nrow(each.mean),2,replace=T),]
each.mean <- lapply(1:length(SW.list), function(x) t(colMeans(each.VT[[x]][,-c(17)])))
each.mean <- ldply(each.mean,data.frame)
each.mean <- as.data.frame(scale(each.mean))
each.mean <-each.mean[,-4]
each.mean <- each.mean[-sample(1:nrow(each.mean),2,replace=T),]
each.mean.val <- each.mean[sample(1:nrow(each.mean),2,replace=T),]
each.mean.val
clstr.val <- predict(clstr.rf, each.mean.val)
clstr.val <- predict(clstr.rf, each.mean.val)[[1]]
clstr.val$predictionseach.mean.val
each.mean.val
clstr.val
clstr.val
PCA <- function(each.VT=each.VT, val_n){
set.seed(123)
each.mean <- lapply(1:length(SW.list), function(x)
t(colMeans(each.VT[[x]][,-c(17)]))) #don't include streamflow on the clustering
each.mean <- ldply(each.mean,data.frame)
each.mean <- as.data.frame(scale(each.mean))
each.mean <-each.mean[,-4] #NA-full column
each.mean <- each.mean[-sample(1:nrow(each.mean),val_n,replace=T),]
each.mean.val <- each.mean[sample(1:nrow(each.mean),val_n,replace=T),]
clstr <- kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)[[1]]
each.mean$clstr = clstr
clstr.rf <- ranger(as.factor(clstr) ~ ., data=each.mean)
clstr.val <- predict(clstr.rf, each.mean.val)[[1]]
list(clstr, clstr.val)
}
#assign clusters from k-means/pca clustering
source('R/PCA.R')
clstr <- PCA(each.VT, 2)
clstr
PCA <- function(each.VT=each.VT){
set.seed(123)
each.mean <- lapply(1:length(SW.list), function(x)
t(colMeans(each.VT[[x]][,-c(17)]))) #don't include streamflow on the clustering
each.mean <- ldply(each.mean,data.frame)
each.mean <- as.data.frame(scale(each.mean))
each.mean <- each.mean[,-4] #NA-full column
kmeans(each.mean, centers = 4,nstart=50,iter.max = 1000)[[1]]
}
clstr <- PCA(each.VT)
clstr
pca1.VT <-  groupVT('pca1', 0.6, 'yes')
pca2.VT <-  groupVT('pca2', 0.6, 'yes')
pca3.VT <-  groupVT('pca3', 0.6, 'yes')
pca4.VT <-  groupVT('pca4', 0.6, 'yes')
head(pca4.VT)
clstr
#all
all.VT.yes <- groupVT('all', 0.6, 'yes')
clstr
SW.list
SW.list[-'crb_p']
SW.list[-1]
SW.list[-12]
# 1. VALUETABLE ASSEMBLY
source('R/groupVT.R')
#all
all.VT.yes <- groupVT('all', 0.6, 'yes')
#watersheds
each.VT <- lapply(1:length(SW.list), function(x) groupVT(SW.list[[x]], 0.6, 'yes'))
#basin
aarb.VT.yes <- groupVT('aarb', 0.6, 'yes')
abrb.VT.yes <- groupVT('abrb', 0.6, 'yes')
arb.VT.yes <- groupVT('arb', 0.6, 'yes')
crb.VT.yes <- groupVT('crb', 0.6, 'yes')
mrb.VT.yes <- groupVT('mrb', 0.6, 'yes')
prb.VT.yes <- groupVT('prb', 0.6, 'yes')
#watersheds
each.VT <- lapply(1:length(SW.list), function(x) groupVT(SW.list[[x]], 0.6, 'yes'))
save.image("D:/THESIS_PP/nov132020.RData")
